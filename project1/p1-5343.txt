
CS 5343 Algorithm analysis and data structures
Project 1: Applications of Queues and Stacks

Due: 11:59 PM, Wednesday Feb 28th, 2024 (elearning).

In this project, you will be using stacks to parse/evaluate arithmetic expressions.
This is an individual project. Do not share your work with others. Do not look for a solution on the net or any other outside sources.
ANY SUSPICION OF PLAGIARISM WILL BE REPORTED to OCSC.

Algorithms to parse infix expressions were discussed in the class.
Algorithm for parsing expression tree and evaluating postfix expressions will be discussed in the next class.

Use ArrayDeque from the Java library for the stacks.  Do not code your own stack.

Starter code Expression.java is provided (in the box folder).
Add additional fields, methods, classes as needed.
Do not change the name of the class or signatures of public methods.

You code should well structured and commented properly. Please follow format specified in Javadoc.

10 points are allocated for style and comments.

The following methods need to be completed.  No error checking is required.
If the expressions passed are valid, then the methods should work correctly.
Given invalid expressions, your program can return wrong values, print error messages, or throw exceptions.

Method to convert String to a Token:
	The string holds exactly one token, with no extra spaces before or after the token.
	Possible tokens are:
    Operators: PLUS ("+"), TIMES ("*"), MINUS ("-"), DIV ("/"), MOD ("%"), POWER ("^")
    Parentheses: OPEN ("("), CLOSE (")")
    Number: NUMBER (any valid string that represents an integer)
    	    Assume that if a token is not an operator or a parenthesis, then it is a number.
	    Use Long.parseLong(tok) to convert string to long.

    Signature: static Token getToken(String tok) {  ... }

    Tokens have a field "priority" that can be used to store precedence of operators during parsing.
    Precedence: {^} > {*, /, %} > {+, -}.  Assume that all operators are left associative.
    Assign your own values to priority of tokens.  Field "number" is used to store
    the value of NUMBER token.  A token "NIL" is defined for internal use and
    it does not correspond to any token in the expressions.  It is a convenient token to
    mark bottom of stack.

Method to convert an infix expression given as a list of tokens into an expression tree:
    Given an infix expression as a list of tokens, return its corresponding expression tree.
    Signature: public static Expression infixToExpression(List<Token> exp) { ... }


Method to convert an infix expression into a postfix expression:
    Given an infix expression as a list of tokens, return its equivalent postfix expression.
    Signature: public static List<Token> infixToPostfix(List<Token> exp) { ... }

Method to evaluate a postfix expression:
    Given a postfix expression, evaluate it and return its value.
    Signature: public static long evaluatePostfix(List<Token> exp) { ... }


Method to evaluate an expression tree:
    Given an expression tree, evaluate it and return its value.
    Signature: public static long evaluateExpression(Expression tree) { ... }

Submission procedure:
Please follow the procedure below. If you do not follow, 10 points will be deducted.

* Create a folder whose name is your netid (NId).
* Place all (java source) files you are submitting in that folder.
* Use "package NId;" in all your java files.
* Include the class files also in your zip file.
* Include a text file named "readme.txt", that explains how to compile and run the code.
* Zip the contents into a single zip.
* If the zip file is bigger than 1 MB, you have included unnecessary files.
* Delete them and create the zip file again.
* Upload the zip file on elearning.
* Submission can be revised before the deadline.
* The final submission before the deadline will be graded.

References:
1. https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/ArrayDeque.html
2. https://docs.oracle.com/javase/tutorial/collections/index.html
3. https://en.wikipedia.org/wiki/Javadoc